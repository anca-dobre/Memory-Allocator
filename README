am declarat variabilele globale: dim-dimensiunea arenei;
				vector-arena
				prim si ultim- indicele de start al primului bloc,
respectiv cel al ultimului bloc;

	   
INITIALIZE: am folosit calloc, astfel ca val este setata la 0;
FINALIZE: se elibereaza memoria
DUMP:se parcurge un for pentru afisare astfel: daca i%16==0 inseamna ca suntem la capat de rand si afisam un enter, urmand sa afisam 4 octeti urmati de un tab;
						afisam vector[i] urmat de un spatiu
						daca i%8==0 si i nu este multiplu de 16 inseamna ca trebuie sa afisam un spatiu, intrucat intre coloana 7 si 8 exista un spatiu in plus
						
ALLOC: variabila ok este 1 cat nu s a alocat memoria
	daca arena este goala si exista loc suficient se aloca memoria, se afiseaza 12, iar ok devine 0. daca nu exista loc se afiseaza 0
	daca exista un singur bloc in arena(cu indexul 0) se va aloca memorie in continuare, avand grija sa facem legatura intre blocul anterior si cel curent si sa scriem in al 3lea intreg din sectiunea de gestiune a noului bloc dimensiunea size;
	in continuare caut un spatiu liber intre tablouri; 
	daca nu gasesc inseamna ca blocul nou va fi alocat in continuarea ultimului
	daca totusi reusesc sa gasesc un spatiu liber si acesta sa fie suficient de mare vom aloca acolo
	la fiecare alocare se asigura completarea sectiunii de gestiune find posibila parcurgerea intre blocul precedent si urmator;
	daca nu s a putut aloca vom afisa 0;
FREE: avem din nou cazuri- daca blocul scos este ultimul, primul sau in mijloc;
	metoda de implementare cu 0 este aceeasi, diferentele constau in legaturile dintre blocurile vecine;
FILL: indexul scade cu 12, astfel ca acesta indica inceputul blocului, facand mai usor parcurgerea lui
	se parcurge fiecare bloc (prin it) inlocuindu se in fiecare datele utilizatorului cat timp nu se depaseste dimensiunea arenei si cat timp nu s au inlocuit mai mult de size octeti;
